\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{tabularx}
\usepackage{array}     
\renewcommand{\arraystretch}{1.5} 

\lstset{
    basicstyle=\ttfamily\small,
    breaklines=true,       
    breakatwhitespace=false,
    frame=single,
    keywordstyle=\color{blue},
    commentstyle=\color{green!50!black},
    stringstyle=\color{red},
}
\geometry{margin=1in}

\title{\fontsize{16}{18}\selectfont Fundamentos y Aplicaciones de Blockchains, Homework 2}
\author{Matías Eliel Waisman}
\date{}

\begin{document}

\maketitle

\section*{Ejercicio 1}

\subsection*{Punto A}

El propósito de una Public Key Infrastructure es incrementar la confianza entre los participantes de una red. Permite verificar y confiar en las firmas digitales emitidas por la entidad certificadora, garantizando la autenticidad de los mensajes y la identidad de los participantes.  

La PKI lo que nos garantiza es que dada una clave publica, esta se puede asociar a una entidad/ persona. Si el problema de concenso requiere asociar a una clave a una entidad, entonces vamos a necesitar tener una PKI. 

En un protocolo con Public Key Infrastructure, una "autoridad certificadora" va a ser el que atestigue que una clave publica esta asociada a una entidad/ persona. 

Un ejemplo en el cual nos beneficia tener una PKI es para para poder resolver los problemas de consenso bizantino con una mayor cantidad de participantes maliciosos. En la siguiente tabla comparo la cantidad de participantes maliciosos máximos que podemos tener para llegar al consenso si no tenemos setup vs si lo tenemos:

\begin{center}
\begin{tabular}{|>{\centering\arraybackslash}m{3cm}|
                >{\centering\arraybackslash}m{5cm}|
                >{\centering\arraybackslash}m{5cm}|}
\hline
\textbf{Problema} & 
\textbf{Máximo número de participantes maliciosos sin Setup} & 
\textbf{Máximo número de participantes maliciosos con Setup} \\
\hline
Consenso & $\frac{N}{3} - 1$ & $\frac{N}{2} - 1$ \\
\hline
Broadcast & $\frac{N}{3} - 1$ & $N - 1$ \\
\hline
\end{tabular}
\end{center}

Pero si nuestro problema de concenso se puede resolver sin necesidad de asociar una firma a una entidad, la PKI no es la que garantiza las propiedades de las firmas digitales. 

Propiedades de las firmas digitales como existential unforgeability, no dependen de la existencia de una PKI, sino del esquema de firma digital en sí y de la robustez de los algoritmos criptográficos que se usen. Un esquema de firmas inseguro, va a seguir siendolo aunque usemos PKI, y uno seguro va a seguir siendolo aunque no usemos PKI. 

\subsection*{Punto B}

En la red de Bitcoin, a diferencia de un sistema distribuido tradicional, los nodos no tienen identidades fijas ni están registrados. 
La red es abierta y dinámica, cualquiera puede unirse o salir en cualquier momento, y no existe un listado de participantes.

Por este motivo, el protocolo de consenso de la blockchain funciona sin depender de una PKI. 
Para el problema de descidir quien va a agregar un nuevo bloque a la cadena, no es necesario asociar una clave pública a una entidad específica para autenticar a los mineros. La selección de quién propone el siguiente bloque se resuelve mediante el mecanismo de Proof of Work, que asegura tanto la autenticidad de los bloques como el consenso sobre el estado de la cadena.

Por más que las transacciones de Bitcoin usan firmas digitales basadas en el esquema ECDSA, no es necesario asociar una firma en una transacción a un usuario. 
Cuando un usuario crea una transacción, la firma con su clave privada, y los demás nodos pueden verificar la validez de esa firma usando la transacción y la clave pública del firmante. 
Esto garantiza que sólo quien posee la clave privada correspondiente a una dirección puede autorizar el gasto de los fondos asociados a ella, no es necesario asociar la transacción a un ente para determinar que fue valida. 

En Bitcoin no existe ninguna autoridad central que emita o certifique las claves públicas empleadas para firmar transacciones. 
Cada usuario genera localmente su propio par de claves, sin que éstas deban estar vinculadas a identidades “reales”.

Por lo tanto, Bitcoin no asume una PKI, ya que la seguridad de sus transacciones dependen de las propiedades de seguridad que nos dan las firmas digitales y de Proof of Work para el consenso.  

\section*{Ejercicio 2}

El algoritmo arranca desde el bloque $\varepsilon$, en lugar de partir de un bloque génesis impredecible, porque asume explícitamente que no pueden ocurrir ataques de pre-cómputo \href{https://dl.acm.org/doi/10.1145/3653445#fn13}{(Fuente)}.

En un ataque de pre-cómputo, un minero malicioso intenta minar bloques válidos por adelantado con el objetivo de revertir o insertar transacciones en la cadena, o bien de aumentar su probabilidad de encontrar el nonce y así imponer sus propios bloques en la cadena. 

Llevar a cabo un ataque de este tipo no es trivial en una blockchain basada en PoW, ya que el contenido del bloque $N+1$ depende del bloque $N$, porque el bloque $N + 1$ debe apuntar al hash del bloque anterior. Si un atacante pudiera predecir el hash del bloque $N$ (y, dado que el \emph{target} es más fácil de conocer, también la dificultad), podría comenzar a buscar el nonce del bloque $N+1$ por adelantado, obteniendo así una ventaja en la carrera por minar el siguiente bloque. \\

Por esta razón, el bloque génesis en Bitcoin fue diseñado de forma impredecible, de modo que ningún minero pudiera comenzar a minar el segundo bloque antes de que el primero estuviera establecido públicamente.

Dado que el protocolo analizado no considera este tipo de ataques, no es necesario ``hardcodear'' un bloque génesis impredecible. \\

Como análisis personal, sin demostración formal, tiene sentido no preocuparse por estos ataques: salvo que el adversario posea un poder de cómputo muy grande (pero menor al 51\%), el ataque es extremadamente difícil de realizar. Porque predecir el hash del bloque $N$ es muy dificil, lo que vuelve poco rentable minar por adelantado sin garantías sobre el contenido real del bloque anterior.

\section*{Ejercicio 3}

\subsection*{Punto A}

Mi idea es usar los prefijos de la cadena y quedarme siempre con la cabeza de ese prefijo para verificar la validez de los bloques del más viejo al más reciente.  

\begin{algorithm}[H]
\caption{Validación de la cadena desde el bloque más viejo}
\begin{algorithmic}[1]
\Function{validate}{$C$}
    \State $b \gets V(x_C)$ 
    \If{$b \land (C \neq \varepsilon)$} 
        \State $\langle s, x, ctr \rangle \gets head(C^{[1]})$ \Comment{Me quedo con el bloque más viejo}
        \If{$validblock^q_T(\langle s, x, ctr \rangle)$} \Comment{Si el primer bloque es válido}
            \State $i \gets 2$ 
            \Repeat \Comment{Repito hasta que $i$ sea mayor a la longitud de la cadena o $b$ sea falso}
                \State $\langle s', x, ctr \rangle \gets head(C^{[i]})$ \Comment{Siguiente bloque al más viejo}
                \If{$validblock^q_T(\langle s', x, ctr \rangle) \land (H(ctr, G(s',x)) = s)$} \Comment{Valido bloque y referencia}
                    \State $s \gets s'$ \Comment{Guardo el hash del bloque actual}
                \Else
                    \State $b \gets False$
                \EndIf
                \State $i \gets i + 1$
            \Until{$(i = len(C) + 1) \lor (b = False)$}
        \EndIf
    \EndIf
    \State \Return $b$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection*{Punto B}

Comenzar la validación desde el primer bloque (el más antiguo) garantiza que cada bloque que consideramos válido realmente lo es, ya que se verifica la validez de toda la cadena de manera constructiva. Esto evita confiar en bloques mas viejos para validar bloques mas nuevos, lo cual podría ocultar errores si un bloque apunta a otro inválido. En cambio al verificar del mas viejo al mas nuevo, nos aseguramos que todos los bloques que afirmamos que son validos realmente lo son.
Te da un invariante el algoritmo.

Una desventaja de comenzar la validación desde el primer bloque es que, en la práctica, los errores de validez son mucho más probables en los bloques más recientes. Por ejemplo, validar el bloque génesis no aporta demasiado, ya que siempre se asume correcto y es altamente improbable que allí esté el error. En consecuencia, este enfoque podría implicar un costo innecesario de verificación de muchos bloques `viejos'' antes de detectar una invalidez en un bloque más reciente. En términos de complejidad asintótica, ambos algoritmos tienen la misma cota superior (en el peor caso deben verificar toda la cadena). Sin embargo, en la práctica resulta más eficiente comenzar desde el bloque más reciente hacia atrás, ya que aumenta la probabilidad de encontrar un bloque inválido más temprano y, por lo tanto, reducir la cantidad de bloques que es necesario verificar.

\section*{Ejercicio 4}
\subsection*{Punto A}
El que pierde va a ser el que pague la recompensa al que gano. 

Para seguir el patron de pull over push, el ganador va a tener que llamar a withdraw, en vez de hacerle un send o transfer. 

Si se logea el evento y se puede enterar todo el mundo para evitar que el jugador 2 siempre espere a que juegue el 1 y luego lea la blockchain para ver el valor que eligio. El usuario va a mandar el mensaje junto a un string aleatorio, siempre de la misma longitud, y despues el contrato va a desencriptarlo con la clave publica. 

El primer código que hicimos con Segundo Sacchi tiene el problema de que si el jugador 2 ve lo que manda el jugador 1 al contrato, va a ganar siempre.  

\begin{lstlisting}[language=Java]
    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.7.0 <0.9.0;

    contract Pennies{
        bool jugo_primero = false; // Cuando juegue el primer jugador lo pongo en True, cuando juegue el segundo lo pongo en False 
        address addr_primero;
        address addr_segundo; 
        bool valor_primero;
        mapping(address => uint256) balance; 
        address[] public customers;

        event Withdrawal(address customer);

        function withdraw() public {
            uint256 b = balance[msg.sender];
            balance[msg.sender] = 0;
            payable(msg.sender).transfer(b);
            emit Withdrawal(msg.sender);
        }

        function jugar(bool valor) public payable{
            require(msg.value >= 0.01 ether); // Si manda mas se lo queda la casa como donacion
            if(jugo_primero){
                // Tenemos a los dos jugadores
                jugo_primero = false; 
                addr_segundo = msg.sender; 
                if(valor_primero == valor){
                    balance[addr_primero] += 0.02 ether;  
                }
                else{
                    balance[addr_segundo] += 0.02 ether;
                }
            }
            else{
                // Estamos esperando al segundo 
                addr_primero = msg.sender;
                jugo_primero = true;
                valor_primero = valor;
            }
        }
    }
\end{lstlisting}

Por lo que 

\end{document}
